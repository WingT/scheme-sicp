(define nil (list))
(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))
(define (scale-tree1 tree factor)
  (map (lambda (x)
          (if (pair? x)
              (scale-tree1 x factor)
              (* x factor)))
       tree))
;2.30~2.31
(define (tree-map proc tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (proc tree))
        (else (cons (tree-map proc (car tree))
                    (tree-map proc (cdr tree))))))
(define (tree-map1 proc tree)
  (map (lambda (x)
         (if (pair? x)
             (tree-map1 proc x)
             (proc x)))
       tree))
(define t (list 1 (list 2 (list 3 4) 5) (list 6 7)))
;2.32
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (x) (cons (car s) x)) rest)))))
;
(define (fibs x)
  (define (fibs-iter a b n)
    (cond ((= n x) a)
          (else (fibs-iter b (+ a b) (+ n 1)))))
  (fibs-iter 0 1 0))
(define (even-fibs n)
  (define (next k)
    (if (> k n)
        nil
        (let ((f (fibs k)))
          (if (= (remainder f 2) 0)
              (cons f (next (+ k 1)))
              (next (+ 1 k))))))
  (next 0))
(even-fibs 6)
(subsets (list 1 2 3))
