;一维表格
(define (make-table)
  (list '*table*))
(define (assoc key records)
  (cond ((null? records) #f)
        ((equal? (caar records) key) (car records))
        (else (assoc key (cdr records)))))
(define (lookup key table)
  (let ((result (assoc key (cdr table))))
    (if result
        (cdr result)
        #f)))
(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value)
                        (cdr table)))))
  'ok)
;二维表格
(define (lookup key1 key2 table)
  (let ((subtable (assoc key1 (cdr table))))
    (if subtable
        (let ((record (assoc key2 (cdr subtable))))
          (if record
              (cdr record)
              #f))
        #f)))
(define (insert! key1 key2 value table)
  (let ((subtable (assoc key1 (cdr table))))
    (if subtable
        (let ((record (assoc key2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key2 value)
                              (cdr subtable)))))
        (set-cdr! table
                  (cons (list key1 (cons key2 value))
                        (cdr table)))))
  'ok)
;创建局部表格
(define (make-table)
  (let ((table (list '*table*)))
    (define (assoc key records)
      (cond ((null? records) #f)
            ((equal? (caar records) key) (car records))
            (else (assoc key (cdr records)))))
    (define (lookup key1 key2)
      (let ((subtable (assoc key1 (cdr table))))
        (if subtable
            (let ((record (assoc key2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key1 key2 value)
      (let ((subtable (assoc key1 (cdr table))))
        (if subtable
            (let ((record (assoc key2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key2 value)
                                  (cdr subtable)))))
            (set-cdr! table
                      (cons (list key1 (cons key2 value))
                            (cdr table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert!) insert!)
            (else (error "Unknown operation"))))
    dispatch))
(define operation-table (make-table))
(define get (operation-table 'lookup))
(define put (operation-table 'insert!))
;3.24
(define (make-table same-key?)
  (let ((table (list '*table*)))
    (define (assoc key records)
      (cond ((null? records) #f)
            ((same-key? (caar records) key) (car records))
            (else (assoc key (cdr records)))))
    (define (lookup key1 key2)
      (let ((subtable (assoc key1 (cdr table))))
        (if subtable
            (let ((record (assoc key2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key1 key2 value)
      (let ((subtable (assoc key1 (cdr table))))
        (if subtable
            (let ((record (assoc key2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key2 value)
                                  (cdr subtable)))))
            (set-cdr! table
                      (cons (list key1 (cons key2 value))
                            (cdr table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert!) insert!)
            (else (error "Unknown operation"))))
    dispatch))
(define operation-table (make-table (lambda (x y)
                                      (< (abs (- x y)) 0.1))))
(define get (operation-table 'lookup))
(define put (operation-table 'insert!))
;3.25
(define (make-table)
  (let ((table (list '*table*)))
    (define (assoc key records)
      (cond ((null? records) #f)
            ((equal? (caar records) key) (car records))
            (else (assoc key (cdr records)))))
    (define (lookup key)
      (define (lookup-iter key table)
        (cond ((and (null? key) (not (pair? (cdr table))))
               (cdr table))
              ((and (not (null? key)) (pair? (cdr table)))
               (let ((subtable (assoc (car key) (cdr table))))
                 (if subtable
                     (lookup-iter (cdr key) subtable)
                     #f)))
              (else #f)))
      (lookup-iter key table))
    (define (make-entry key value)
      (if (null? (cdr  key))
          (cons (car key) value)
          (list (car key)
                (make-entry (cdr key) value))))
    (define (insert! key value)
      (define (insert!-iter key value table)
        (if (not (pair? (cdr table)))
            (let ((new-entry (make-entry key value)))
              (set-cdr! table (list new-entry)))
            (let ((record (assoc (car key) (cdr table))))
              (if record
                  (if (null? (cdr key))
                      (set-cdr! record value)
                      (insert!-iter (cdr key) value record))
                  (let ((new-entry (make-entry key value)))
                    (set-cdr! table
                              (cons new-entry (cdr table))))))))
      (if (null? key)
          (error "empty key!")
          (insert!-iter key value table))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert!) insert!)
            (else (error "Unknown operation"))))
    dispatch))
(define operation-table (make-table))
(define get (operation-table 'lookup))
(define put (operation-table 'insert!))
;3.26
(define (make-table equal-key? bigger-key?)
  (let ((table (list '*table*)))
    (define (make-record left-branch right-branch key value)
      (list left-branch right-branch key value))
    (define (assoc key record)
      (cond ((null? record) #f)
            ((equal-key? key (caddr record)) record)
            ((bigger-key? key (caddr record))
             (assoc key (cadr record)))
            (else (assoc key (car record)))))
    (define (lookup key)
      (let ((record (assoc key (cdr table))))
        (if record
            (cadddr record)
            #f)))
    (define (insert! key value)
      (define (insert!-iter record)
        (cond ((equal-key? key (caddr record))
               (set-car! (cdddr record) value))
              ((bigger-key? key (caddr record))
               (if (null? (cadr record))
                   (set-car! (cdr record)
                             (make-record '() '() key value))
                   (insert!-iter (cadr record))))
              (else (if (null? (car record))
                        (set-car! record
                                  (make-record '() '() key value))
                        (insert!-iter (car record))))))
      (if (null? (cdr table))
          (set-cdr! table (make-record '() '() key value))
          (insert!-iter (cdr table)))
      'ok)
    (define (dispatch m)
      (cond ((equal? m 'lookup) lookup)
            ((equal? m 'insert!) insert!)
            (else (error "wrong operation type!"))))
    dispatch))
(define operation-table (make-table = >))
(define put (operation-table 'insert!))
(define get (operation-table 'lookup))
;3.27
(define (memoize f)
  (let ((operation-table (make-table = >)))
    (let ((put (operation-table 'insert!))
          (get (operation-table 'lookup)))
      (lambda (x)
        (let ((previous-result (get x)))
          (or previous-result
              (let ((result (f x)))
                (put x result)
                result)))))))
(define memo-fib
  (memoize (lambda (x)
             (cond ((= x 0) 0)
                   ((= x 1) 1)
                   (else (+ (memo-fib (- x 1))
                            (memo-fib (- x 2))))))))
